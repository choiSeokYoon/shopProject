{"ast":null,"code":"var loggerManager = require('./loggerManager.js'),\n  EventEmitter = require('events').EventEmitter,\n  assert = require('assert'),\n  util = require('util'),\n  _ = require('underscore'),\n  path = require('path'),\n  fs = require('fs');\n\n// Get a reference to the active logger to avoid need to get it for each call.\nvar logger = loggerManager.get();\n\n//Watch for updates to the logger and update our reference when it changes.\nloggerManager.on('updated', function (lgr) {\n  logger = lgr;\n});\nvar TypeManager = function () {\n  var descriptors = [],\n    typeManager = this;\n  this.registerType = function (descriptor) {\n    var instance;\n    if (_.isString(descriptor)) {\n      debugger;\n      logger.info('Retrieving descriptor from \"' + descriptor + '\"');\n      instance = JSON.parse(fs.readFileSync(descriptor));\n    } else {\n      instance = descriptor;\n    }\n    assert(instance.name, '\"name\" is a required property.');\n    assert(instance.type, '\"type\" is a required property.');\n    logger.info('Registering ' + instance.name + ' descriptor as type \"' + instance.type + '\"');\n    switch (instance.type) {\n      case 'STATIC':\n        descriptors.push(instance);\n        break;\n    }\n    typeManager.emit('registered', instance);\n  };\n\n  /**\n   * registerTypes allows you to register mulitiple types.\n   *\n   * Note: This function will block to avoid starting the server in\n   * an incomplete state.\n   *\n   * @param descriptors A path to a directory containing type descriptors, an array \n   * type descriptor file names or an array of type descriptor instances.\n   */\n  this.registerTypes = function (descriptors) {\n    var references;\n    // If a path was passed in, retrieve the file list.\n    if (_.isString(descriptors)) {\n      logger.info('Retrieving a list of descriptor files from \"' + descriptors + '\"');\n      references = fs.readdirSync(descriptors);\n      references = _.map(references, function (reference) {\n        return path.join(descriptors, reference);\n      });\n      // If an array of paths were passed, store a reference in paths for\n      // later processing.\n    } else if (descriptors.length && _.isString(descriptors[0])) {\n      references = descriptors;\n    }\n    _.each(references, function (reference) {\n      // If the reference is a string, pass it on as long as it has a \".json\" extension.\n      if (_.isString(reference)) {\n        if (reference.substr(-5) === '.json') {\n          typeManager.registerType(reference);\n        }\n        // If the reference is descriptor instances, just pass it on\n        // as they are.\n      } else {\n        typeManager.registerType(reference);\n      }\n    });\n  };\n  EventEmitter.call(this);\n};\nutil.inherits(TypeManager, EventEmitter);\nmodule.exports = TypeManager;","map":{"version":3,"names":["loggerManager","require","EventEmitter","assert","util","_","path","fs","logger","get","on","lgr","TypeManager","descriptors","typeManager","registerType","descriptor","instance","isString","info","JSON","parse","readFileSync","name","type","push","emit","registerTypes","references","readdirSync","map","reference","join","length","each","substr","call","inherits","module","exports"],"sources":["C:/Users/82107/Desktop/프론트엔드/프로젝트/쇼핑몰/shop/node_modules/reset/lib/TypeManager.js"],"sourcesContent":["var loggerManager = require('./loggerManager.js'),\n\tEventEmitter = require('events').EventEmitter,\n\tassert = require('assert'),\n\tutil = require('util'),\n\t_ = require('underscore'),\n\tpath = require('path'),\n\tfs = require('fs');\n\t\n// Get a reference to the active logger to avoid need to get it for each call.\nvar logger = loggerManager.get();\n\n//Watch for updates to the logger and update our reference when it changes.\nloggerManager.on('updated', function(lgr) {\n\tlogger = lgr;\n});\n\nvar TypeManager = function() {\n\tvar descriptors = [],\n\t\ttypeManager = this;\n\n\tthis.registerType = function(descriptor) {\n\t\tvar instance;\n\t\tif (_.isString(descriptor)) {\n\t\t\tdebugger;\n\t\t\tlogger.info('Retrieving descriptor from \"' + descriptor + '\"');\n\t\t\tinstance = JSON.parse(fs.readFileSync(descriptor));\n\t\t} else {\n\t\t\tinstance = descriptor;\n\t\t}\n\t\tassert(instance.name, '\"name\" is a required property.');\n\t\tassert(instance.type, '\"type\" is a required property.');\n\t\tlogger.info('Registering ' + instance.name + ' descriptor as type \"' + instance.type + '\"');\n\t\tswitch (instance.type) {\n\t\t\tcase 'STATIC':\n\t\t\t\tdescriptors.push(instance);\n\t\t\t\tbreak;\n\t\t}\n\t\ttypeManager.emit('registered', instance);\n\t};\n\n\t/**\n\t * registerTypes allows you to register mulitiple types.\n\t *\n\t * Note: This function will block to avoid starting the server in\n\t * an incomplete state.\n\t *\n\t * @param descriptors A path to a directory containing type descriptors, an array \n\t * type descriptor file names or an array of type descriptor instances.\n\t */\n\tthis.registerTypes = function(descriptors) {\n\t\tvar references;\n\t\t// If a path was passed in, retrieve the file list.\n\t\tif (_.isString(descriptors)) {\n\t\t\tlogger.info('Retrieving a list of descriptor files from \"' + descriptors + '\"');\n\t\t\treferences = fs.readdirSync(descriptors);\n\t\t\treferences = _.map(references, function(reference) {\n\t\t\t\treturn path.join(descriptors, reference);\n\t\t\t});\n\t\t// If an array of paths were passed, store a reference in paths for\n\t\t// later processing.\n\t\t} else if (descriptors.length && _.isString(descriptors[0])) {\n\t\t\treferences = descriptors;\n\t\t}\n\n\t\t\n\t\t_.each(references, function(reference) {\n\t\t\t// If the reference is a string, pass it on as long as it has a \".json\" extension.\n\t\t\tif (_.isString(reference)) {\n\t\t\t\tif (reference.substr(-5) === '.json') {\n\t\t\t\t\ttypeManager.registerType(reference);\n\t\t\t\t}\n\t\t\t// If the reference is descriptor instances, just pass it on\n\t\t\t// as they are.\n\t\t\t} else {\n\t\t\t\ttypeManager.registerType(reference);\n\t\t\t}\n\t\t});\n\t};\n\n\tEventEmitter.call(this);\n};\n\nutil.inherits(TypeManager, EventEmitter);\n\nmodule.exports = TypeManager;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}