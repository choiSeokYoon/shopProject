{"ast":null,"code":"/*\n * reset\n * https://github.com/tfoster/reset\n *\n * Copyright (c) 2013 Tyler Foster\n * Licensed under the MIT license.\n */\n\n'use strict';\n\nvar loggerManager = require('./loggerManager.js'),\n  TypeManager = require('./TypeManager.js'),\n  HandlerFactory = require('./HandlerFactory.js'),\n  _ = require('underscore'),\n  url = require('url'),\n  path = require('path'),\n  fs = require('fs'),\n  assert = require('assert');\n\n// Get a reference to the active logger to avoid need to get it for each call.\nvar logger = loggerManager.get();\n\n//Watch for updates to the logger and update our reference when it changes.\nloggerManager.on('updated', function (lgr) {\n  logger = lgr;\n});\nvar Reset = function (server, context) {\n  this.server = server.addListener('request', this.requestRouter.bind(this));\n  this.context = context || '/';\n  this.handlers = {};\n  logger.info('Initializing REST server...');\n  this.handlerFactory = new HandlerFactory(this.context);\n  this.typeManager = new TypeManager(this.context);\n  this.typeManager.on('registered', function (descriptor) {\n    this.handlers[descriptor.name] = this.handlerFactory.create(descriptor);\n  }.bind(this));\n};\nReset.prototype.requestRouter = function (req, res) {\n  try {\n    // We need to ensure the request is within the current instances context.\n    if (req.url.length < this.context || req.url.substr(0, this.context.length) !== this.context) {\n      return;\n    }\n    var parsedUrl = url.parse(req.url),\n      pathSansContext = parsedUrl.path.substr(this.context.length),\n      resourceName = path.dirname(pathSansContext);\n    this.handlers[resourceName].handle(req, res);\n  } catch (e) {\n    logger.error(e);\n  }\n};\nReset.prototype.registerType = function (descriptor) {\n  this.typeManager.registerType(descriptor);\n};\n\n/**\n * registerTypes allows you to register mulitiple types.\n *\n * Note: This function will block to avoid starting the server in\n * an incomplete state.\n *\n * @param descriptors A path to a directory containing type descriptors, an array \n * type descriptor file names or an array of type descriptor instances.\n */\nReset.prototype.registerTypes = function (descriptors) {\n  this.typeManager.registerTypes(descriptors);\n};\nReset.setLogger = function (lgr) {\n  loggerManager.set(lgr);\n};\nReset.getLogger = function () {\n  return loggerManager.get();\n};\nmodule.exports = Reset;","map":{"version":3,"names":["loggerManager","require","TypeManager","HandlerFactory","_","url","path","fs","assert","logger","get","on","lgr","Reset","server","context","addListener","requestRouter","bind","handlers","info","handlerFactory","typeManager","descriptor","name","create","prototype","req","res","length","substr","parsedUrl","parse","pathSansContext","resourceName","dirname","handle","e","error","registerType","registerTypes","descriptors","setLogger","set","getLogger","module","exports"],"sources":["C:/Users/82107/Desktop/프론트엔드/프로젝트/쇼핑몰/shop/node_modules/reset/lib/reset.js"],"sourcesContent":["/*\n * reset\n * https://github.com/tfoster/reset\n *\n * Copyright (c) 2013 Tyler Foster\n * Licensed under the MIT license.\n */\n\n'use strict';\nvar loggerManager = require('./loggerManager.js'),\n\tTypeManager = require('./TypeManager.js'),\n\tHandlerFactory = require('./HandlerFactory.js'),\n\t_ = require('underscore'),\n\turl = require('url'),\n\tpath = require('path'),\n\tfs = require('fs'),\n\tassert = require('assert');\n\n// Get a reference to the active logger to avoid need to get it for each call.\nvar logger = loggerManager.get();\n\n//Watch for updates to the logger and update our reference when it changes.\nloggerManager.on('updated', function(lgr) {\n\tlogger = lgr;\n});\n\nvar Reset = function(server, context) {\n\tthis.server = server.addListener('request', this.requestRouter.bind(this));\n\tthis.context = context || '/';\n\tthis.handlers = {};\n\tlogger.info('Initializing REST server...');\n\tthis.handlerFactory = new HandlerFactory(this.context);\n\tthis.typeManager = new TypeManager(this.context);\n\n\tthis.typeManager.on('registered', (function(descriptor) {\n\t\tthis.handlers[descriptor.name] = this.handlerFactory.create(descriptor);\n\t}).bind(this));\n};\n\nReset.prototype.requestRouter = function(req, res) {\n\ttry {\n\t\t// We need to ensure the request is within the current instances context.\n\t\tif (req.url.length < this.context ||\n\t\t\treq.url.substr(0, this.context.length) !== this.context) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar parsedUrl = url.parse(req.url),\n\t\t\tpathSansContext = parsedUrl.path.substr(this.context.length),\n\t\t\tresourceName = path.dirname(pathSansContext);\n\t\tthis.handlers[resourceName].handle(req, res);\n\t} catch (e) {\n\t\tlogger.error(e);\n\t}\n};\n\nReset.prototype.registerType = function(descriptor) {\n\tthis.typeManager.registerType(descriptor);\n};\n\n/**\n * registerTypes allows you to register mulitiple types.\n *\n * Note: This function will block to avoid starting the server in\n * an incomplete state.\n *\n * @param descriptors A path to a directory containing type descriptors, an array \n * type descriptor file names or an array of type descriptor instances.\n */\nReset.prototype.registerTypes = function(descriptors) {\n\tthis.typeManager.registerTypes(descriptors);\n}\n\nReset.setLogger =function(lgr) {\n\tloggerManager.set(lgr);\n};\n\nReset.getLogger = function() {\n\treturn loggerManager.get();\n};\n\nmodule.exports = Reset;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}